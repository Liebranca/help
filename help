#!/usr/bin/perl

# ---   *   ---   *   --- +
# HL                      |
# makes help messages     |

# LIBRE SOFTWARE          |
# Licensed under GNU GPL3 |
# be a bro and inherit    |

# CONTRIBUTORS            |
# lyeb,                   |

# ---   *   ---   *   --- +

# deps
  use strict;
  use warnings;

  # for testing we use an abspath
  # later on cash would be on @INC
  use lib glob '~/AR/help/';
  use cash;

  # ^likewise
  use lib glob '~/AR/avtomat/';
  use avt;

# ---   *   ---   *   ---

  use constant {
    VERSION => "0.1b" ,

  };

sub help {

  print "Usage: help <'opt0'> <'d0'> ... <'optN'> <'dN'>\n";
  print "help formats (option,description) pair-list to tty size\n\n";

  my @OPTS=@_;
  unshift @OPTS,'inception';
  system './help',@OPTS;

  write_format();

  exit;

};sub version {
  print avt::version(
    'help',VERSION,
    'help message and commandline dev utils',
    'IBN-3DILA',
    
  );exit;

};

# ---   *   ---   *   ---

# det N chars to allocate per field
sub gen_fields {

  # get console size in chars
  my ($y,$x)=cash::tty_sz;

  # generate template
  my $n_field;  
  my $d_field;{

    # set sizes according to screen  
    my $d_sz=int($x/1.5)-12;
    my $n_sz=$x-$d_sz-12;

    # string paste
    $n_field='@'.( '<'x$n_sz );
    $d_field='@'.( '<'x$d_sz );

  };return ($n_field,$d_field);

};

# ---   *   ---   *   ---

# opts=(name,desc...) pair list
# cut provided opts so they format wrap
sub parse_opts {

  my @opts=@ARGV;
  my ($n_field,$d_field)=gen_fields;

  my $n_space=length $n_field;
  my $d_space=length $d_field;

  my @lines=();my ($x,$y)=(0,0);
  my ($sz_x,$sz_y)=(0,0);

# ---   *   ---   *   ---

  # iter through pairs
  while(@opts) {
    my $n=shift @opts;
    my $d=shift @opts;

    $lines[$x][$y][0]='';
    $lines[$x][$y][1]='';$y=0;

    # cut name string into lines
    my $sub=1;while($sub) {      
      ($sub,$n)=cash::wrap_word($n,$n_space);
      if(!$sub) {last;}
      
      $lines[$x][$y][0]=$sub;
      $y++;

    };$lines[$x][$y][0]=$n;

# ---   *   ---   *   ---

    # now cut description
    $y=0;$sub=1;while($sub) {
      ($sub,$d)=cash::wrap_word($d,$d_space);
      if(!$sub) {last;}
      
      $lines[$x][$y][1]=$sub;$y++;
      $sz_y+=$y>=$sz_y;

    };$lines[$x][$y][1]=$d;$y++;
    $lines[$x][$y][1]=' ';
    
    $x++;$sz_x++;$sz_y=($y>$sz_y) ? $y : $sz_y;

  };

  return (\@lines,$sz_x,$sz_y,(' 'x4).$n_field.(' 'x6).$d_field);

};

# ---   *   ---   *   ---

# single arg=parsed opts array
# outs file with format print
sub make_format {

  my ($lines_ref,$sz_x,$sz_y,$line_format)=@_;
  my @lines=@{ $lines_ref };

  # iter lines
  my @lines_flat=();
  for(my $x=0;$x<$sz_x;$x++) {
    for(my $y=0;$y<=$sz_y;$y++) {

      # blank name & desc
      if(!$lines[$x][$y][0] && !$lines[$x][$y][1]) {
        next;

      };

      # only one is blank, still need it for padding
      if   (!$lines[$x][$y][0]) {$lines[$x][$y][0]='';}
      elsif(!$lines[$x][$y][1]) {$lines[$x][$y][1]='';};

      push @lines_flat,'"'.$lines[$x][$y][0].'"';
      push @lines_flat,'"'.$lines[$x][$y][1].'"';

    };
  };

# ---   *   ---   *   ---

  # oh, here it comes
  open FH,'>','./helpme';
  print FH '#!/usr/bin/perl'."\n";
  print FH "\n".avt::note('IBN-3DILA','#')."\n";
  print FH 'my ($name,$desc);'."\n\n";
  print FH 'my @lines=('."\n";
  while(@lines_flat) {
    my $s=shift @lines_flat;
    print FH "$s,\n";

  };
  
  print FH "\n);\n\n";

  # first print the generated format itself
  print FH 'format HELPME='."\n";
  print FH $line_format."\n";
  print FH '$name, $desc'."\n";
  print FH '.'."\n";

# ---   *   ---   *   ---

  # now check it  
  print FH <<'EOF'

# single arg=parsed opts array
# outs file with format print

select(STDOUT);$~="HELPME";

# iter lines
while(@lines) {
  $name=shift @lines;
  $desc=shift @lines;

  write;

};

EOF

  # God I'm so meta
  ;close FH;`chmod +x ./helpme`;

};

# ---   *   ---   *   ---

# runs the generated code
sub write_format {
  print "OPTIONS:\n";
  print `./helpme`;
};

# ---   *   ---   *   ---
# arg handler

# list+hash for checking passed options
my @OPTS=(
    '-g,--generate','generates the format script without running it',
    '-h,--help'    ,'show this message',
    '-v,--version' ,'print version info and exit',
    
);my %OPTS=cash::make_arg_keys(@OPTS);

# ---   *   ---   *   ---

my $gen_only=0;

# no args provided
if(!@ARGV) {
  help @OPTS;

} elsif($ARGV[0] ne 'inception') {

  my @passed=@{ cash::argchk(\@ARGV,\%OPTS) };

  # else check for options
  while(@passed) {

    my $opt_i=shift @passed;
    shift @ARGV;

    if   ($opt_i==0) {$gen_only=1 ;}
    elsif($opt_i==1) {help @OPTS  ;}
    elsif($opt_i==2) {version     ;};

  };

} else {shift;$gen_only=1;};

# ---   *   ---   *   ---

#!($#ARGV%2)

my @ar=parse_opts();
make_format @ar;

if(!$gen_only) {write_format;};

# ---   *   ---   *   ---
1; # ret
