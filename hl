#!/usr/bin/perl

# ---   *   ---   *   --- +
# HL                      |
# makes help messages     |

# LIBRE SOFTWARE          |
# Licensed under GNU GPL3 |
# be a bro and inherit    |

# CONTRIBUTORS            |
# lyeb,                   |

# ---   *   ---   *   --- +

# deps
  use strict;
  use warnings;

  # for testing we use an abspath
  # later on cash would be on @INC
  use lib glob '~/AR/hl/';
  use cash;

# ---   *   ---   *   ---

  use constant {
    VERSION => "0.1b" ,

  };

sub help_me {

  print "Usage: hl <'opt0'> <'d0'> ... <'optN'> <'dN'>\n";
  print "hl formats (option,description) pair-list to tty\n\n";

  my @ar=parse_opts();
  make_format @ar;
  write_format @ar;

  exit;  

};sub view_version {
  print '>hl v'.VERSION."\n\n";
  print 'help message and commandline dev utils'."\n";
  print 'Copyleft IBN-3DILA'.YEAR.'; licensed under GNU GPL3'."\n\n";
  
  exit;

};

# ---   *   ---   *   ---

# det N chars to allocate per field
sub gen_fields {

  # get console size in chars
  my ($y,$x)=cash::tty_sz;

  # generate template
  my $n_field;  
  my $d_field;{

    # set sizes according to screen  
    my $d_sz=int($x/1.5)-12;
    my $n_sz=$x-$d_sz-12;

    # string paste
    $n_field='@'.( '<'x$n_sz );
    $d_field='@'.( '<'x$d_sz );

  };return ($n_field,$d_field);

};

# ---   *   ---   *   ---

# opts=(name,desc...) pair list
# cut provided opts so they format wrap
sub parse_opts {

  my @opts=@ARGV;
  my ($n_field,$d_field)=gen_fields;

  my $n_space=length $n_field;
  my $d_space=length $d_field;

  my @lines=();my ($x,$y)=(0,0);
  my ($sz_x,$sz_y)=(0,0);

# ---   *   ---   *   ---

  # iter through pairs
  while(@opts) {
    my $n=shift @opts;
    my $d=shift @opts;

    $lines[$x][$y][0]='';
    $lines[$x][$y][1]='';$y=0;

    # cut name string into lines
    my $sub=1;while($sub) {      
      ($sub,$n)=cash::wrap_word($n,$n_space);
      if(!$sub) {last;}
      
      $lines[$x][$y][0]=$sub;
      $y++;

    };$lines[$x][$y][0]=$n;

# ---   *   ---   *   ---

    # now cut description
    $y=0;$sub=1;while($sub) {
      ($sub,$d)=cash::wrap_word($d,$d_space);
      if(!$sub) {last;}
      
      $lines[$x][$y][1]=$sub;$y++;
      $sz_y+=$y>=$sz_y;

    };$lines[$x][$y][1]=$d;$y++;
    $lines[$x][$y][1]=' ';
    
    $x++;$sz_x++;$sz_y=($y>$sz_y) ? $y : $sz_y;

  };

  return (\@lines,$sz_x,$sz_y,(' 'x4).$n_field.(' 'x6).$d_field);

};

# ---   *   ---   *   ---

# single arg=parsed opts array
# outs file with format print
sub make_format {

  my ($lines_ref,$sz_x,$sz_y,$line_format)=@_;
  my @lines=@{ $lines_ref };

  # oh, here it comes
  open FH,'>','./helpme';
  print FH '#!/usr/bin/perl'."\n";
  print FH '# libre helpme generated by AR/hl';
  print FH 'my ($name,$desc);'."\n";

  # first print the generated format itself
  print FH 'format HELPME='."\n";
  print FH $line_format."\n";
  print FH '$name, $desc'."\n";
  print FH '.'."\n";

# ---   *   ---   *   ---

  # now check it  
  print FH <<'EOF'

# single arg=parsed opts array
# outs file with format print

my $line_format=$ARGV[0];shift;
my @lines=@ARGV;

select(STDOUT);$~="HELPME";

# iter lines
while(@lines) {
  $name=shift @lines;
  $desc=shift @lines;

  write;

};

EOF

  # God I'm so meta
  ;close FH;`chmod +x ./helpme`;

};

# ---   *   ---   *   ---

# runs the generated code
sub write_format {
  my ($lines_ref,$sz_x,$sz_y,$line_format)=@_;
  my @lines=@{ $lines_ref };
  my @lines_flat=();

  print "OPTIONS:\n";

  # iter lines
  for(my $x=0;$x<$sz_x;$x++) {
    for(my $y=0;$y<=$sz_y;$y++) {

      # blank name & desc
      if(!$lines[$x][$y][0] && !$lines[$x][$y][1]) {
        next;

      };

      # only one is blank, still need it for padding
      if   (!$lines[$x][$y][0]) {$lines[$x][$y][0]='';}
      elsif(!$lines[$x][$y][1]) {$lines[$x][$y][1]='';};

      push @lines_flat,'"'.$lines[$x][$y][0].'"'; 
      push @lines_flat,'"'.$lines[$x][$y][1].'"';

    };
    
  };print `./test "$line_format" @lines_flat`;
};

# ---   *   ---   *   ---
# arg handler

# list+hash for checking passed options
my @OPTS=(
    '-g,--generate','generates the format script without running it',
    '-h,--help'    ,'show this message',
    '-v,--version' ,'print version info and exit',
    
);my %OPTS=cash::make_arg_keys(@OPTS);

# ---   *   ---   *   ---

# no args provided
if(!@ARGV) {help_me;};my @passed=@{ cash::argchk(\@ARGV,\%OPTS) };

# else check for options
while(@passed) {

  my $opt_i=shift @passed;
  shift @ARGV;
  
  if   ($opt_i==1) {help_me     ;};
  elsif($opt_i==2) {view_version;};

};exit;

# ---   *   ---   *   ---

#!($#ARGV%2)
#
#my @ar=parse_opts();
#make_format @ar;
#write_format @ar;

# ---   *   ---   *   ---
